input {
  # TCP input para aplicaciones (JSON logs)
  tcp {
    port => 5000
    codec => json_lines
    type => "tcp-json"
  }

  # Beats input (Filebeat - Docker logs)
  beats {
    port => 5044
    type => "beats"
  }

  # HTTP input (REST API para logs)
  http {
    port => 8080
    codec => json
    type => "http-json"
  }
}

filter {
  # Parse JSON si viene como string
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "parsed"
      remove_field => ["message"]
    }

    # Mover campos parseados al nivel raíz
    ruby {
      code => "
        if event.get('parsed')
          event.get('parsed').each { |k, v| event.set(k, v) }
          event.remove('parsed')
        end
      "
    }
  }

  # Agregar timestamp si no existe
  if ![timestamp] {
    ruby {
      code => "event.set('timestamp', event.get('@timestamp'))"
    }
  }

  # Normalizar nivel de log
  if [level] {
    mutate {
      lowercase => ["level"]
    }
  }

  # Determinar índice basado en aplicación
  if [application] {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "ait-%{application}" }
    }
  } else if [container] and [container][name] {
    # Para logs de Docker detectados por Filebeat
    if [container][name] =~ /ain-tech-web/ {
      mutate {
        add_field => {
          "[@metadata][index_prefix]" => "ait-ain-tech-web"
          "application" => "ain-tech-web"
        }
      }
    } else if [container][name] =~ /soriano-ecliente/ {
      mutate {
        add_field => {
          "[@metadata][index_prefix]" => "ait-soriano-ecliente"
          "application" => "soriano-ecliente"
        }
      }
    } else if [container][name] =~ /ait-core/ {
      mutate {
        add_field => {
          "[@metadata][index_prefix]" => "ait-ait-core"
          "application" => "ait-core"
        }
      }
    } else if [container][name] =~ /ait-engine/ {
      mutate {
        add_field => {
          "[@metadata][index_prefix]" => "ait-ait-engines"
          "application" => "ait-engines"
        }
      }
    } else if [container][name] =~ /kong/ {
      mutate {
        add_field => {
          "[@metadata][index_prefix]" => "ait-kong"
          "application" => "kong"
        }
      }
    } else {
      mutate {
        add_field => { "[@metadata][index_prefix]" => "ait-general" }
      }
    }
  } else {
    mutate {
      add_field => {
        "[@metadata][index_prefix]" => "ait-general"
        "application" => "unknown"
      }
    }
  }

  # Enriquecimiento con GeoIP (si hay client_ip)
  if [client_ip] and [client_ip] != "" and [client_ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/ {
    geoip {
      source => "client_ip"
      target => "geoip"
      fields => ["city_name", "country_name", "country_code2", "location", "continent_code"]
    }
  }

  # Parse User Agent
  if [user_agent] and [user_agent] != "" {
    useragent {
      source => "user_agent"
      target => "ua"
    }
  }

  # Categorizar severidad de errores
  if [level] {
    if [level] == "error" or [level] == "fatal" or [level] == "critical" {
      mutate {
        add_field => { "severity" => "high" }
        add_tag => ["alert"]
      }
    } else if [level] == "warn" or [level] == "warning" {
      mutate {
        add_field => { "severity" => "medium" }
      }
    } else {
      mutate {
        add_field => { "severity" => "low" }
      }
    }
  }

  # Parse stack traces para mejor visualización
  if [stack] {
    mutate {
      gsub => [
        "stack", "\n", " | "
      ]
    }
  }

  # Extraer información de performance
  if [duration] {
    ruby {
      code => "
        duration = event.get('duration')
        if duration.is_a?(Numeric)
          if duration > 5000
            event.set('performance_category', 'very_slow')
          elsif duration > 1000
            event.set('performance_category', 'slow')
          elsif duration > 500
            event.set('performance_category', 'acceptable')
          else
            event.set('performance_category', 'fast')
          end
        end
      "
    }
  }

  # Agregar etiquetas de entorno
  if [environment] {
    mutate {
      add_tag => ["%{environment}"]
    }
  }

  # Remover campos innecesarios
  mutate {
    remove_field => ["host", "agent", "ecs", "log", "input", "tags"]
  }
}

output {
  # Output a Elasticsearch con índices por aplicación y fecha
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
    index => "%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
    document_type => "_doc"
    # Template para gestión de índices
    template_name => "ait-logs"
    template_overwrite => true
  }

  # Output a consola en desarrollo (comentar en producción)
  # stdout {
  #   codec => rubydebug {
  #     metadata => true
  #   }
  # }
}
